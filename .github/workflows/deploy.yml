name: Deploy to Amazon ECR & EC2

on:
  push:
    branches: [ main ]

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: intune-chat-repo
  CONTAINER_NAME: intune-chat
  EC2_INSTANCE_IDS: "i-08100c71ecc821618,i-07ee03b6f1f176e41"
  DOCKER_RUN_ARGS: >-
    -p 8081:8081
    --restart unless-stopped

jobs:
  deploy:
    name: Build → Push(ECR) → Deploy(EC2 Private)
    runs-on: ubuntu-latest
    environment: production

  steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@0e613a0980cbf65ed5b322eb7a1e075d28913a83
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@62f4f872db3836360b72999f4b87f1ff13310f3a

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        set -euo pipefail
        docker build -t "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG" .
        docker push "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
        echo "image=$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG" >> "$GITHUB_OUTPUT"
        
    # === 여기부터 Private EC2로 배포(SSM RunCommand) ===
    - name: Build SSM command script
      id: ssm-script
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_URI: ${{ steps.build-image.outputs.image }}
        CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
        DOCKER_RUN_ARGS: ${{ env.DOCKER_RUN_ARGS }}
      run: |
        set -euo pipefail
        cat > deploy.sh <<'EOF'
        #!/usr/bin/env bash
        set -euo pipefail
        
        echo "[1/5] ECR 로그인"
        aws ecr get-login-password --region "${AWS_REGION}" \
          | docker login --username AWS --password-stdin "${ECR_REGISTRY}"
        
        echo "[2/5] 새 이미지 Pull: ${IMAGE_URI}"
        docker pull "${IMAGE_URI}"
        
        echo "[3/5] 기존 컨테이너 정리: ${CONTAINER_NAME}"
        # 동일 이름 컨테이너가 있으면 중지/삭제
        if docker ps -a --format '{{.Names}}' | grep -wq "${CONTAINER_NAME}"; then
          docker rm -f "${CONTAINER_NAME}" || true
        fi
        
        echo "[4/5] 오래된 이미지 가비지 정리(선택)"
        docker image prune -f || true
        
        echo "[5/5] 새 컨테이너 기동"
        docker run -d --name "${CONTAINER_NAME}" ${DOCKER_RUN_ARGS} "${IMAGE_URI}"
        
        echo "DONE"
        EOF
        
        COMMANDS_JSON=$(jq -Rs . < deploy.sh)
        echo "commands=[\"bash\",\"-lc\",$COMMANDS_JSON]" >> "$GITHUB_OUTPUT"

      - name: Send SSM RunCommand to EC2 (by InstanceIds or by Tag)
        id: ssm-deploy
        run: |
          set -euo pipefail
          
          TARGETS_JSON="[]"
          if [ -n "${{ env.EC2_INSTANCE_IDS }}" ]; then
          
            # InstanceId로 지정
            IFS=',' read -ra IDS <<< "${{ env.EC2_INSTANCE_IDS }}"
            ARR=""
            for id in "${IDS[@]}"; do
              ARR="${ARR}{\"Key\":\"InstanceIds\",\"Values\":[\"$id\"]},"
            done
            TARGETS_JSON="["${ARR%,}"]"
          elif [ -n "${{ env.EC2_TAG_KEY || '' }}" ] && [ -n "${{ env.EC2_TAG_VALUE || '' }}" ]; then
            # 태그로 지정
            TARGETS_JSON=$(cat <<JSON
          [
            {"Key":"tag:${{ env.EC2_TAG_KEY }}","Values":["${{ env.EC2_TAG_VALUE }}"]}
          ]
          JSON
          )
          else
            echo "EC2 타깃(EC2_INSTANCE_IDS 또는 EC2_TAG_KEY/EC2_TAG_VALUE)을 설정하세요." >&2
            exit 1
          fi
          
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --comment "Pull from ECR and restart container" \
            --targets "${TARGETS_JSON}" \
            --parameters '{"commands": '${{ steps.ssm-script.outputs.commands }}'}' \
            --timeout-seconds 1800 \
            --max-concurrency "1" \
            --max-errors "0" \
            --region "${{ env.AWS_REGION }}" \
            --output json > send-command.json
          
          COMMAND_ID=$(jq -r '.Command.CommandId' send-command.json)
          echo "command-id=${COMMAND_ID}" >> "$GITHUB_OUTPUT"
          
      - name: Wait for SSM command to finish
        run: |
          set -euo pipefail
          COMMAND_ID="${{ steps.ssm-deploy.outputs.command-id }}"
          echo "Waiting for SSM Command $COMMAND_ID ..."
          # 간단 폴링
          for i in $(seq 1 120); do
            STATUS=$(aws ssm list-commands --command-id "$COMMAND_ID" --query "Commands[0].Status" --output text --region "${{ env.AWS_REGION }}")
            echo "SSM Status: $STATUS"
            case "$STATUS" in
              Success) exit 0 ;;
              Failed|Cancelled|TimedOut) echo "SSM failed: $STATUS"; exit 1 ;;
            esac
            sleep 5
          done
          echo "Timeout waiting SSM command"
          exit 1
